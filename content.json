[{"title":"moduleJs-IIFE","date":"2017-02-18T14:53:14.000Z","path":"2017/02/18/moduleJs-IIFE/","text":"","tags":[]},{"title":"JavaScript函数节流和函数防抖之间的区别","date":"2017-02-14T23:15:35.000Z","path":"2017/02/15/throttleAndDebounce/","text":"一、概念解释 函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。 大家大概都知道旧款电视机的工作原理，就是一行行得扫描出色彩到屏幕上，然后组成一张张图片。由于肉眼只能分辨出一定频率的变化，当高频率的扫描，人类是感觉不出来的。反而形成一种视觉效果，就是一张图。就像高速旋转的风扇，你看不到扇叶，只看到了一个圆一样。 同理，可以类推到js代码。在一定时间内，代码执行的次数不一定要非常多。达到一定频率就足够了。因为跑得越多，带来的效果也是一样。倒不如，把js代码的执行次数控制在合理的范围。既能节省浏览器CPU资源，又能让页面浏览更加顺畅，不会因为js的执行而发生卡顿。这就是函数节流和函数防抖要做的事。 函数节流是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。 函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。 二、函数节流 函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码： 1234567891011121314// 函数节流var canRun = true;document.getElementById(\"throttle\").onscroll = function()&#123; if(!canRun)&#123; // 判断是否已空闲，如果在执行中，则直接return return; &#125; canRun = false; setTimeout(function()&#123; console.log(\"函数节流\"); canRun = true; &#125;, 300);&#125;; 函数节流的要点是，声明一个变量当标志位，记录当前代码是否在执行。 如果空闲，则可以正常触发方法执行。 如果代码正在执行，则取消这次方法执行，直接return。 这个方法的作用是监听ID为throttle元素的滚动事件。 当canRun为true，则代表现在的滚动处理事件是空闲的，可以使用。 通过关卡if(!canRun)，等于就拿到了通行证。然后下一步的操作就是立马将关卡关上canRun=false。这样，其他请求执行滚动事件的方法，就被挡回去了。 接着用setTimeout规定最小的时间间隔300，接着再执行setTimeout方法体里面的内容。 最后，等setTimeout里面的方法都执行完毕，才释放关卡canRun=true，允许下一个访问者进来。 这个函数节流的实现形式，需要注意的是执行的间隔时间是&gt;=300ms。如果具体执行的方法是包含callback的，也可以将canRun=true这一步放到callback中。理解了函数节流的关卡设置重点，其实改起来就简单多了。 三、函数防抖 函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析： 123456789// 函数防抖var timer = false;document.getElementById(\"debounce\").onscroll = function()&#123; clearTimeout(timer); // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function()&#123; console.log(\"函数防抖\"); &#125;, 300);&#125;; 函数防抖的要点，也是需要一个setTimeout来辅助实现。延迟执行需要跑的代码。 如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。 如果计时完毕，没有方法进来访问触发，则执行代码。 这个方法的作用是监听ID为debounce元素的滚动事件 进入滚动事件方法体的时候，做的第一件事就是清除上次未执行的setTimeout。而setTimeout的引用id由变量timer记录。 clearTimeout方法，允许传入无效的值。所以这里直接执行clearTimeout即可。 然后，将需要执行的代码放入setTimeout中，再返回setTimeout引用给timer缓存。 如果倒计时300ms以后，还没有新的方法触发滚动事件，则执行setTimeout中的代码。 函数防抖的实现重点，就是巧用setTimeout做缓存池，而且可以轻易地清除待执行的代码。 其实，用队列的方式也可以做到这种效果。这里就不深入了。 四、在线demo 这是我写的一个测试demo，把鼠标移动到模块上方，滚动滚轮，即可在控制台查看输出效果。 demo地址：https://wall-wxk.github.io/blogDemo/2017/02/15/throttleAndDebounce.html","tags":[{"name":"throttle","slug":"throttle","permalink":"https://wall-wxk.github.io/tags/throttle/"},{"name":"debounce","slug":"debounce","permalink":"https://wall-wxk.github.io/tags/debounce/"}]},{"title":"JavaScript嗅探执行神器-sniffer.js，你值得拥有！","date":"2017-02-13T16:29:16.000Z","path":"2017/02/14/sniffer/","text":"一、热身——先看实战代码 a.js 文件 1234567891011121314151617// 定义Wall及内部方法;(function(window, FUNC, undefined)&#123; var name = 'wall'; Wall.say = function(name)&#123; console.log('I\\'m '+ name +' !'); &#125;; Wall.message = &#123; getName : function()&#123; return name; &#125;, setName : function(firstName, secondName)&#123; name = firstName+'-'+secondName; &#125; &#125;;&#125;)(window, window.Wall || (window.Wall = &#123;&#125;)); index.jsp文件 12345678910111213141516&lt;script type='text/javascript'&gt; &lt;% // Java 代码直出 js out.print(\"Sniffer.run(&#123;'base':window,'name':'Wall.say','subscribe':true&#125;, 'wall');\\n\"); %&gt; // Lab.js是一个文件加载工具 // 依赖的a.js加载完毕后，则可执行缓存的js方法 $LAB.script(\"a.js\").wait(function()&#123; // 触发已订阅的方法 Sniffer.trigger(&#123; 'base':window, 'name':'Wall.say' &#125;); &#125;);&lt;/script&gt; 这样，不管a.js文件多大，Wall.say(&#39;wall&#39;)都可以等到文件真正加载完后，再执行。 二、工具简介123456// 执行 Wall.message.setName('wang', 'wall');Sniffer.run(&#123; 'base':Wall, 'name':'message.setName', 'subscribe':true&#125;, 'wang', 'wall'); 看这个执行代码，你也许会感觉困惑-什么鬼！ sniffer.js作用就是可以试探执行方法，如果不可执行，也不会抛错。 比如例子Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;); 如果该方法所在文件还没有加载，也不会报错。 处理的逻辑就是先缓存起来，等方法加载好后，再进行调用。 再次调用的方法如下： 12345// 触发已订阅的方法Sniffer.trigger(&#123; 'base':Wall, 'name':'message.setName'&#125;); 在线demo:https://wall-wxk.github.io/blogDemo/2017/02/13/sniffer.html (需要在控制台看，建议用pc) 说起这个工具的诞生，是因为公司业务的需要，自己写的一个工具。 因为公司的后台语言是java，喜欢用jsp的out.print()方法，直接输出一些js方法给客户端执行。 这就存在一个矛盾点，有时候js文件还没下载好，后台输出的语句已经开始调用方法，这就很尴尬。 所以，这个工具的作用有两点： 1. 检测执行的js方法是否存在，存在则立即执行。 2. 缓存暂时不存在的js方法，等真正可执行的时候，再从缓存队列里面拿出来，触发执行。 三、嗅探核心基础——运算符in 方法是通过使用运算符in去遍历命名空间中的方法，如果取得到值，则代表可执行。反之，则代表不可执行。 通过这个例子，就可以知道这个sniffer.js的嗅探原理了。 四、抽象出嗅探方法12345678910111213141516171819202122232425262728/*** @function &#123;private&#125; 检测方法是否可用* @param &#123;string&#125; funcName -- 方法名***.***.**** @param &#123;object&#125; base -- 方法所依附的对象 **/function checkMethod(funcName, base)&#123; var methodList = funcName.split('.'), // 方法名list readyFunc = base, // 检测合格的函数部分 result = &#123; 'success':true, 'func':function()&#123;&#125; &#125;, // 返回的检测结果 methodName, // 单个方法名 i; for(i = 0; i &lt; methodList.length; i++)&#123; methodName = methodList[i]; if(methodName in readyFunc)&#123; readyFunc = readyFunc[methodName]; &#125;else&#123; result.success = false; return result; &#125; &#125; result.func = readyFunc; return result; &#125; 像Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);这样的方法，要判断是否可执行，需要执行以下步骤： 1. 判断Wall是否存在window中。 2. Wall存在，则继续判断message是否在Wall中。 3. message存在，则继续判断setName是否在message中 4. 最后，都判断存在了，则代表可执行。如果中间的任意一个检测不通过，则方法不可执行。 五、实现缓存 缓存使用闭包实现的。以队列的性质，存储在list中 1234567891011121314;(function(FUN, undefined)&#123; 'use strict' var list = []; // 存储订阅的需要调用的方法 // 执行方法 FUN.run = function()&#123; // 很多代码... //将订阅的函数缓存起来 list.push(...); &#125;; &#125;)(window.Sniffer || (window.Sniffer = &#123;&#125;)); 六、确定队列中单个项的内容 1. 指定检测的基点 base 由于运算符in工作时，需要几个基点给它检测。所以第一个要有的项就是base 2. 检测的字符类型的方法名 name 像Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);，如果已经指定基点{&#39;base&#39;:Wall}，则还需要message.setName。所以要存储message.setName，也即{&#39;base&#39;:Wall, &#39;name&#39;:&#39;message.setName&#39;} 3. 缓存方法的参数 args 像Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);，有两个参数(&#39;wang&#39;, &#39;wall&#39;)，所以需要存储起来。也即{&#39;base&#39;:Wall, &#39;name&#39;:&#39;message.setName&#39;, &#39;args&#39;:[&#39;wang&#39;, &#39;wall&#39;]}。 为什么参数使用数组缓存起来，是因为方法的参数是变化的，所以后续的代码需要apply去做触发。同理，这里的参数就需要用数组进行缓存 所以，缓存队列的单个项内容如下：12345&#123; 'base':Wall, 'name':'message.setName', 'args':['wang', 'wall']&#125; 七、实现run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061;(function(FUN, undefined)&#123; 'use strict' var list = []; // 存储订阅的需要调用的方法 /** * @function 函数转换接口，用于判断函数是否存在命名空间中，有则调用，无则不调用 * @version &#123;create&#125; 2015-11-30 * @description * 用途：只设计用于延迟加载 * 示例：Wall.mytext.init(45, false); * 调用：Sniffer.run(&#123;'base':window, 'name':'Wall.mytext.init'&#125;, 45, false); 或 Sniffer.run(&#123;'base':Wall, 'name':'mytext.init'&#125;, 45, false); * 如果不知道参数的个数，不能直接写，可以用apply的方式调用当前方法 * 示例: Sniffer.run.apply(window, [ &#123;'name':'Wall.mytext.init'&#125;, 45, false ]); **/ FUN.run = function()&#123; if(arguments.length &lt; 1 || typeof arguments[0] != 'object')&#123; throw new Error('Sniffer.run 参数错误'); return; &#125; var name = arguments[0].name, // 函数名 0位为Object类型，方便做扩展 subscribe = arguments[0].subscribe || false, // 订阅当函数可执行时，调用该函数, true:订阅; false:不订阅 prompt = arguments[0].prompt || false, // 是否显示提示语(当函数未能执行的时候) promptMsg = arguments[0].promptMsg || '功能还在加载中，请稍候', // 函数未能执行提示语 base = arguments[0].base || window, // 基准对象，函数查找的起点 args = Array.prototype.slice.call(arguments), // 参数列表 funcArgs = args.slice(1), // 函数的参数列表 callbackFunc = &#123;&#125;, // 临时存放需要回调的函数 result; // 检测结果 result = checkMethod(name, base); if(result.success)&#123; subscribe = false; try&#123; return result.func.apply(result.func, funcArgs); // apply调整函数的指针指向 &#125;catch(e)&#123; (typeof console != 'undefined') &amp;&amp; console.log &amp;&amp; console.log('错误:name='+ e.name +'; message='+ e.message); &#125; &#125;else&#123; if(prompt)&#123; // 输出提示语到页面，代码略 &#125; &#125; //将订阅的函数缓存起来 if(subscribe)&#123; callbackFunc.name = name; callbackFunc.base = base; callbackFunc.args = funcArgs; list.push(callbackFunc); &#125; &#125;; // 嗅探方法 function checkMethod(funcName, base)&#123; // 代码... &#125;&#125;)(window.Sniffer || (window.Sniffer = &#123;&#125;)); run方法的作用是：检测方法是否可执行，可执行，则执行。不可执行，则根据传入的参数，决定要不要缓存。 这个run方法的重点，是妙用arguments，实现0-n个参数自由传入。 第一个形参arguments[0]，固定是用来传入配置项的。存储要检测的基点base，方法字符串argument[0].name以及缓存标志arguments[0].subscribe。 第二个形参到第n个形参，则由方法调用者传入需要使用的参数。 利用泛型方法，将arguments转换为真正的数组。（args = Array.prototype.slice.call(arguments)） 然后，切割出方法调用需要用到的参数。（funcArgs = args.slice(1)） run方法的arguments处理完毕后，就可以调用checkMethod方法进行嗅探。 根据嗅探的结果，分两种情况： 嗅探结果为可执行，则调用apply执行 return result.func.apply(result.func, funcArgs); 这里的重点是必须制定作用域为result.func，也即例子的Wall.message.setName。 这样，如果方法中使用了this，指向也不会发生改变。 使用return，是因为一些方法执行后是有返回值的，所以这里需要加上return，将返回值传递出去。 嗅探结果为不可执行，则根据传入的配置值subscribe，决定是否缓存到队列list中。 需要缓存，则拼接好队列单个项，push进list。 八、实现trigger方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061;(function(FUN, undefined)&#123; 'use strict' var list = []; // 存储订阅的需要调用的方法 // 执行方法 FUN.run = function()&#123; // 代码... &#125;; /** * @function 触发函数接口，调用已提前订阅的函数 * @param &#123;object&#125; option -- 需要调用的相关参数 * @description * 用途：只设计用于延迟加载 * 另外，调用trigger方法的前提是，订阅方法所在js已经加载并解析完毕 * 不管触发成功与否，都会清除list中对应的项 **/ FUN.trigger = function(option)&#123; if(typeof option !== 'object')&#123; throw new Error('Sniffer.trigger 参数错误'); return; &#125; var funcName = option.name || '', // 函数名 base = option.base || window, // 基准对象，函数查找的起点 newList = [], // 用于更新list result, // 检测结果 func, // 存储执行方法的指针 i, // 遍历list param; // 临时存储list[i] if(funcName.length &lt; 1)&#123; return; &#125; // 遍历list，执行对应的函数，并将其从缓存池list中删除 for(i = 0; i &lt; list.length; i++)&#123; param = list[i]; if(param.name == funcName)&#123; result = checkMethod(funcName, base); if( result.success )&#123; try&#123; result.func.apply(result.func, param.args); &#125;catch(e)&#123; (typeof console != 'undefined') &amp;&amp; console.log &amp;&amp; console.log('错误:name='+ e.name +'; message='+ e.message); &#125; &#125; &#125;else&#123; newList.push(param); &#125; &#125; list = newList; &#125;; // 嗅探方法 function checkMethod(funcName, base)&#123; // 代码... &#125;&#125;)(window.Sniffer || (window.Sniffer = &#123;&#125;)); 如果前面的run方法看懂了，trigger方法也就不难理解了。 1. 首先要告知trigger方法，需要从队列list中拿出哪个方法执行。 2. 在执行方法之前，需要再次嗅探这个方法是否已经存在。存在了，才可以执行。否则，则可以认为方法已经不存在，可以从缓存中移除。 九、实用性和可靠度 实用性这方面是毋容置疑的，不管是什么代码栈，Sniffer.js都值得你拥有！ 可靠度方面，Sniffer.js使用在高流量的公司产品上，至今没有出现反馈任何兼容、或者性能问题。这方面也可以打包票！ 最后，附上源码地址:https://github.com/wall-wxk/sniffer/blob/master/sniffer.js","tags":[{"name":"sniffer.js","slug":"sniffer-js","permalink":"https://wall-wxk.github.io/tags/sniffer-js/"}]},{"title":"localStorage的黑科技-js和css缓存机制","date":"2017-01-18T12:30:36.000Z","path":"2017/01/18/localStorage/","text":"一、发现黑科技的起因 今天在微信公众号看到一篇技术博文，想用印象笔记收藏，所以发送了文章链接到pc上。然后习惯性地打开控制台，看看源码，想了解下最近微信用了什么新技术。 呵呵，以下勾起了我侦探的欲望。页面加载后的异常点就是只加载了一个js，如下图所示： 我很诧异，为什么已经开启了Disable cache，js只加载了一个，而且体积这么小。接着，我按住Ctrl+O进行资源文件查找，发现我被“忽悠”了。其实根本就不止一个js文件。 脑袋里灵光一闪，不会是用localStorage做了缓存吧？！赶紧看了下localStronge,还真是。。。。 心里一阵澎湃，这不是我之前就想实现的加载性能优化的想法吗！乖乖，我孤陋寡闻了，已经有前端团队实现了代码。 二、谈谈文件加载方面的优化思路 通常，前端的资源文件加载优化，就是在文件不修改迭代的情况下，尽可能多地利用缓存，避免多次下载同样的文件。 一般的做法就是尽量延长资源的有效期，也就是设置 Cache-Control里的max-age，使页面资源请求的返回码为304，让浏览器直接使用本地缓存。 虽然pc端的协商缓存（304）很快，但手机端因为网络原因，协商缓存的效果就没pc端那么好了。而且，手机会经常清除本地缓存，所以文件缓存的时间也不会很长。 这个时候，localStorage就派上用场了。 localStorage相比cookie，可以缓存大体积的数据，而且是永久有效。所以，如果把js资源和css资源存储在localStorage中，则可以省去发送http请求所消耗的时间，大大提高用户的浏览体验。 三、用localStorage做资源缓存需要解决的问题3.1 版本更新机制 只要一个项目还在迭代开发，就难以避免需要更新资源文件。 普通的资源请求，可以根据 文件名+md5 http://res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/moon32ebc4.js 或者 在资源链接后面加上特定的后缀http://1.ss.faisys.com/js/comm/fai.min.js?v=201612051739 做标识来判断是否需要更新资源。 如果用localStorage做，则需要一套新的缓存更新机制。 3.2 搭建更新代码的脚手架 使用localStorage缓存，则需要一个新的脚手架来管理资源文件的读取和写入。 3.3 后台输出一份资源配置信息 因为需要前端做资源更新，所以后台要输出一份依据给前端做判断用，也就是需要一份资源配置信息。前端根据配置信息，进行匹配和比较，最终决定 使用localStorage缓存，还是重新发起请求，下载最新的资源文件。 3.4 存在XSS安全隐患 localStorage中的信息，客户端是可以任意修改的。如果哪个黑客想练手一下，可以任意注入js代码。那么，在页面刷新的时候，注入的代码也将会被执行。 四、微信的做法解析4.1 版本标识 以__MOON__a/a_report.js为例，版本信息用key __MOON__a/a_report.js_ver存储，存储的value为//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_report32e586.js。 如果按普通加载方式，直接将该value取出来，设置到script节点的src属性，即可完成加载。 微信判断该版本是否最新，就是用该value值与后台输出的配置信息进行比较，最后得出是否更新的结果。 如果value值与配置信息一致，则使用缓存。否则，重新发起请求加载。 4.2 脚手架 可以看出，微信使用的是自己开发的脚手架moon.js，在这个网页中的实际文件名是moon32ebc4.js。 因为是混淆过变量名的文件，所以要看出具体代码的走向，有点费劲，这里就不做分析了。 4.3 资源配置信息 因为脚手架moon.js需要资源配置信息才能正常工作，所以配置信息一定会在moon.js之前输出。 依次查看moon.js之前的script标签，发现了window.moon_map这个json对象。 利用控制台输出该变量查看信息如下： 看到这里，可以明确一个点：这就是更新机制所必备的资源配置信息表了。 而且，可以看出，该配置信息json对象的key，就对应localStorage中的key。同理，value值也是一一对应。 4.4 XSS攻击 此处是为了验证微信的缓存机制是否存在XSS攻击，看到这里的童鞋可千万不要去做坏事。 我在一个js缓存代码中，插入alert(&quot;hehe&quot;);，看页面刷新的时候，是否会出现该弹窗，来验证是否存在攻击漏洞。 刷新页面后，结果如下图： 可以看出，微信也没有解决这类问题。所以，这种缓存机制，还是有先天不足的。 4.5 测试微信的更新机制 修改localStorage中 key __MOON__a/a_report.js_ver对应的value值，让微信的脚手架moon.js更新__MOON__a/a_report.js，刷掉我刚才主动插入的代码。 这里，我修改文件名为***587.js（原来的文件名为***586.js）。接着F5刷新页面。 结果为：report.js代码更新了，版本号也恢复回 ***586.js。 五、结论 localStorage缓存有其用武之地，但不是万能的。需要注意以上提及的坑。 可以应用的场景我归纳为以下几点： 1. 非首屏渲染需要的css文件，可以做LS缓存。 首屏渲染需要的css，需要按常规方式输出，因为SEO需要，不然爬虫爬取页面的时候，页面效果会很不好。而非首屏的css，则可以用LS缓存，减少资源下载时间。 2. 展示类、动画类等非业务主要逻辑的代码，可以做LS缓存。 这样，可以一定程度上避免业务层的安全漏洞。当然，前端再怎么做防护都是一层薄纸。重要的，还是后台接口要做好安全保护。 3. 移动端可以做LS缓存。PC端做LS缓存，起到的优化作用不大。 六、番外 有兴趣的童鞋，还可以看看知乎上大神们的讨论，静态资源（JS/CSS）存储在localStorage有什么缺点？为什么没有被广泛应用？ - 互联网 - 知乎 另外，腾讯网的前端，在gitHub上有分享其MT 模块管理框架，可以看看具体的实现逻辑。 最后，上一个栗子 —— 线上实例demo：webapp模块化开发体系","tags":[{"name":"IIFE","slug":"IIFE","permalink":"https://wall-wxk.github.io/tags/IIFE/"}]}]