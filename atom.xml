<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wall&#39;s blog</title>
  <subtitle>努力向上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wall-wxk.github.io/"/>
  <updated>2017-02-18T14:24:38.000Z</updated>
  <id>https://wall-wxk.github.io/</id>
  
  <author>
    <name>wall</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript函数节流和函数防抖之间的区别</title>
    <link href="https://wall-wxk.github.io/2017/02/15/throttleAndDebounce/"/>
    <id>https://wall-wxk.github.io/2017/02/15/throttleAndDebounce/</id>
    <published>2017-02-14T23:15:35.000Z</published>
    <updated>2017-02-18T14:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概念解释"><a href="#一、概念解释" class="headerlink" title="一、概念解释"></a>一、概念解释</h2><p> 函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。<br> 大家大概都知道旧款电视机的工作原理，就是一行行得扫描出色彩到屏幕上，然后组成一张张图片。由于肉眼只能分辨出一定频率的变化，当高频率的扫描，人类是感觉不出来的。反而形成一种视觉效果，就是一张图。就像高速旋转的风扇，你看不到扇叶，只看到了一个圆一样。<br> 同理，可以类推到js代码。在一定时间内，代码执行的次数不一定要非常多。达到一定频率就足够了。因为跑得越多，带来的效果也是一样。倒不如，把js代码的执行次数控制在合理的范围。既能节省浏览器CPU资源，又能让页面浏览更加顺畅，不会因为js的执行而发生卡顿。这就是函数节流和函数防抖要做的事。</p>
<p> <strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。<br> <strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p>
<h2 id="二、函数节流"><a href="#二、函数节流" class="headerlink" title="二、函数节流"></a>二、函数节流</h2><p> 函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数节流</span></div><div class="line"><span class="keyword">var</span> canRun = <span class="literal">true</span>;</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"throttle"</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(!canRun)&#123;</div><div class="line">		<span class="comment">// 判断是否已空闲，如果在执行中，则直接return</span></div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	canRun = <span class="literal">false</span>;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"函数节流"</span>);</div><div class="line">		canRun = <span class="literal">true</span>;</div><div class="line">	&#125;, <span class="number">300</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 函数节流的要点是，声明一个变量当标志位，记录当前代码是否在执行。<br> 如果空闲，则可以正常触发方法执行。<br> 如果代码正在执行，则取消这次方法执行，直接<code>return</code>。</p>
<blockquote>
<p> 这个方法的作用是监听ID为<code>throttle</code>元素的滚动事件。<br> 当<code>canRun</code>为<code>true</code>，则代表现在的滚动处理事件是空闲的，可以使用。<br> 通过关卡<code>if(!canRun)</code>，等于就拿到了通行证。然后下一步的操作就是立马将关卡关上<code>canRun=false</code>。这样，其他请求执行滚动事件的方法，就被挡回去了。<br> 接着用<code>setTimeout</code>规定最小的时间间隔300，接着再执行<code>setTimeout</code>方法体里面的内容。<br> 最后，等<code>setTimeout</code>里面的方法都执行完毕，才释放关卡<code>canRun=true</code>，允许下一个访问者进来。</p>
</blockquote>
<p> 这个函数节流的实现形式，需要注意的是执行的间隔时间是<code>&gt;=300ms</code>。如果具体执行的方法是包含<code>callback</code>的，也可以将<code>canRun=true</code>这一步放到<code>callback</code>中。理解了函数节流的关卡设置重点，其实改起来就简单多了。</p>
<h2 id="三、函数防抖"><a href="#三、函数防抖" class="headerlink" title="三、函数防抖"></a>三、函数防抖</h2><p> 函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数防抖</span></div><div class="line"><span class="keyword">var</span> timer = <span class="literal">false</span>;</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"debounce"</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	clearTimeout(timer); <span class="comment">// 清除未执行的代码，重置回初始化状态</span></div><div class="line"></div><div class="line">	timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"函数防抖"</span>);</div><div class="line">	&#125;, <span class="number">300</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 函数防抖的要点，也是需要一个<code>setTimeout</code>来辅助实现。延迟执行需要跑的代码。<br> 如果方法多次触发，则把上次记录的延迟执行代码用<code>clearTimeout</code>清掉，重新开始。<br> 如果计时完毕，没有方法进来访问触发，则执行代码。</p>
<blockquote>
<p> 这个方法的作用是监听ID为<code>debounce</code>元素的滚动事件<br> 进入滚动事件方法体的时候，做的第一件事就是清除上次未执行的<code>setTimeout</code>。而<code>setTimeout</code>的引用id由变量<code>timer</code>记录。<br> <code>clearTimeout</code>方法，允许传入无效的值。所以这里直接执行<code>clearTimeout</code>即可。<br> 然后，将需要执行的代码放入<code>setTimeout</code>中，再返回<code>setTimeout</code>引用给timer缓存。<br> 如果倒计时<code>300ms</code>以后，还没有新的方法触发滚动事件，则执行<code>setTimeout</code>中的代码。</p>
</blockquote>
<p> 函数防抖的实现重点，就是巧用<code>setTimeout</code>做缓存池，而且可以轻易地清除待执行的代码。<br> 其实，用队列的方式也可以做到这种效果。这里就不深入了。</p>
<h2 id="四、在线demo"><a href="#四、在线demo" class="headerlink" title="四、在线demo"></a>四、在线demo</h2><p><img src="http://upload-images.jianshu.io/upload_images/4118463-3b282a8aa813070b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数节流和函数防抖"></p>
<p> 这是我写的一个测试demo，把鼠标移动到模块上方，滚动滚轮，即可在控制台查看输出效果。</p>
<p> <a href="https://wall-wxk.github.io/blogDemo/2017/02/15/throttleAndDebounce.html">demo地址</a>：<code>https://wall-wxk.github.io/blogDemo/2017/02/15/throttleAndDebounce.html</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概念解释&quot;&gt;&lt;a href=&quot;#一、概念解释&quot; class=&quot;headerlink&quot; title=&quot;一、概念解释&quot;&gt;&lt;/a&gt;一、概念解释&lt;/h2&gt;&lt;p&gt; 函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。&lt;br&gt; 大家大概都知道旧款电视机的工作原理
    
    </summary>
    
      <category term="JavaScript" scheme="https://wall-wxk.github.io/categories/JavaScript/"/>
    
    
      <category term="throttle" scheme="https://wall-wxk.github.io/tags/throttle/"/>
    
      <category term="debounce" scheme="https://wall-wxk.github.io/tags/debounce/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript嗅探执行神器-sniffer.js，你值得拥有！</title>
    <link href="https://wall-wxk.github.io/2017/02/14/sniffer/"/>
    <id>https://wall-wxk.github.io/2017/02/14/sniffer/</id>
    <published>2017-02-13T16:29:16.000Z</published>
    <updated>2017-02-18T14:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、热身——先看实战代码"><a href="#一、热身——先看实战代码" class="headerlink" title="一、热身——先看实战代码"></a>一、热身——先看实战代码</h2><blockquote>
<p>a.js 文件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Wall及内部方法</span></div><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">window, FUNC, undefined</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> name = <span class="string">'wall'</span>;</div><div class="line"></div><div class="line">	Wall.say = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'I\'m '</span>+ name +<span class="string">' !'</span>);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Wall.message = &#123;</div><div class="line">		<span class="attr">getName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> name;</div><div class="line">		&#125;,</div><div class="line">		<span class="attr">setName</span> : <span class="function"><span class="keyword">function</span>(<span class="params">firstName, secondName</span>)</span>&#123;</div><div class="line">			name = firstName+<span class="string">'-'</span>+secondName;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.Wall || (<span class="built_in">window</span>.Wall = &#123;&#125;));</div></pre></td></tr></table></figure>
<blockquote>
<p>index.jsp文件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</div><div class="line">	&lt;%</div><div class="line">		// Java 代码直出 js</div><div class="line">		out.print("Sniffer.run(&#123;'base':window,'name':'Wall.say','subscribe':true&#125;, 'wall');\n");</div><div class="line">	%&gt;</div><div class="line"></div><div class="line">	// Lab.js是一个文件加载工具</div><div class="line">	// 依赖的a.js加载完毕后，则可执行缓存的js方法</div><div class="line">	$LAB.script("a.js").wait(function()&#123;</div><div class="line">		// 触发已订阅的方法</div><div class="line">		Sniffer.trigger(&#123;</div><div class="line">			'base':window,</div><div class="line">			'name':'Wall.say'</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p> 这样，不管a.js文件多大，<code>Wall.say(&#39;wall&#39;)</code>都可以等到文件真正加载完后，再执行。</p>
<h2 id="二、工具简介"><a href="#二、工具简介" class="headerlink" title="二、工具简介"></a>二、工具简介</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行 Wall.message.setName('wang', 'wall');</span></div><div class="line">Sniffer.run(&#123;</div><div class="line">	<span class="string">'base'</span>:Wall,</div><div class="line">	<span class="string">'name'</span>:<span class="string">'message.setName'</span>,</div><div class="line">	<span class="string">'subscribe'</span>:<span class="literal">true</span></div><div class="line">&#125;, <span class="string">'wang'</span>, <span class="string">'wall'</span>);</div></pre></td></tr></table></figure>
<p> 看这个执行代码，你也许会感觉困惑-什么鬼！</p>
<p> sniffer.js作用就是可以试探执行方法，如果不可执行，也不会抛错。</p>
<p> 比如例子<code>Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);</code><br> 如果该方法所在文件还没有加载，也不会报错。<br> 处理的逻辑就是先缓存起来，等方法加载好后，再进行调用。</p>
<p> 再次调用的方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 触发已订阅的方法</span></div><div class="line">Sniffer.trigger(&#123;</div><div class="line">	<span class="string">'base'</span>:Wall,</div><div class="line">	<span class="string">'name'</span>:<span class="string">'message.setName'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> <a href="https://wall-wxk.github.io/blogDemo/2017/02/13/sniffer.html">在线demo</a>:<code>https://wall-wxk.github.io/blogDemo/2017/02/13/sniffer.html</code> (需要在控制台看，建议用pc)</p>
<p> 说起这个工具的诞生，是因为公司业务的需要，自己写的一个工具。<br> 因为公司的后台语言是java，喜欢用jsp的out.print()方法，直接输出一些js方法给客户端执行。<br> 这就存在一个矛盾点，有时候js文件还没下载好，后台输出的语句已经开始调用方法，这就很尴尬。</p>
<p> 所以，这个<strong>工具的作用有两点</strong>：</p>
<p> 1. 检测执行的js方法是否存在，存在则立即执行。<br> 2. 缓存暂时不存在的js方法，等真正可执行的时候，再从缓存队列里面拿出来，触发执行。</p>
<h2 id="三、嗅探核心基础——运算符in"><a href="#三、嗅探核心基础——运算符in" class="headerlink" title="三、嗅探核心基础——运算符in"></a>三、嗅探核心基础——运算符<code>in</code></h2><p> 方法是通过使用运算符<code>in</code>去遍历命名空间中的方法，如果取得到值，则代表可执行。反之，则代表不可执行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-204345c78931e181.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运算符 in"></p>
<p> 通过这个例子，就可以知道这个sniffer.js的嗅探原理了。</p>
<h2 id="四、抽象出嗅探方法"><a href="#四、抽象出嗅探方法" class="headerlink" title="四、抽象出嗅探方法"></a>四、抽象出嗅探方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* @function &#123;private&#125; 检测方法是否可用</div><div class="line">* @param &#123;string&#125; funcName -- 方法名***.***.***</div><div class="line">* @param &#123;object&#125; base -- 方法所依附的对象 </div><div class="line">**/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMethod</span>(<span class="params">funcName, base</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> methodList = funcName.split(<span class="string">'.'</span>), <span class="comment">// 方法名list</span></div><div class="line">		readyFunc = base, <span class="comment">// 检测合格的函数部分</span></div><div class="line">		result = &#123;</div><div class="line">			<span class="string">'success'</span>:<span class="literal">true</span>,</div><div class="line">			<span class="string">'func'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">		&#125;, <span class="comment">// 返回的检测结果</span></div><div class="line">		methodName, <span class="comment">// 单个方法名</span></div><div class="line">		i;</div><div class="line">		</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; methodList.length; i++)&#123;</div><div class="line">		methodName = methodList[i];</div><div class="line">		<span class="keyword">if</span>(methodName <span class="keyword">in</span> readyFunc)&#123;</div><div class="line">			readyFunc = readyFunc[methodName];</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			result.success = <span class="literal">false</span>;</div><div class="line">			<span class="keyword">return</span> result;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	result.func = readyFunc;</div><div class="line">	<span class="keyword">return</span> result; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 像<code>Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);</code>这样的方法，要判断是否可执行，需要执行以下步骤：<br> 1. 判断<code>Wall</code>是否存在<code>window</code>中。<br> 2. <code>Wall</code>存在，则继续判断<code>message</code>是否在<code>Wall</code>中。<br> 3. <code>message</code>存在，则继续判断<code>setName</code>是否在<code>message</code>中<br> 4. 最后，都判断存在了，则代表可执行。如果中间的任意一个检测不通过，则方法不可执行。</p>
<h2 id="五、实现缓存"><a href="#五、实现缓存" class="headerlink" title="五、实现缓存"></a>五、实现缓存</h2><p> 缓存使用闭包实现的。以队列的性质，存储在<code>list</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">FUN, undefined</span>)</span>&#123;</div><div class="line"><span class="meta">	'use strict'</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> list = []; <span class="comment">// 存储订阅的需要调用的方法</span></div><div class="line"></div><div class="line">	<span class="comment">// 执行方法</span></div><div class="line">	FUN.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">// 很多代码...</span></div><div class="line">		</div><div class="line">		<span class="comment">//将订阅的函数缓存起来</span></div><div class="line">		list.push(...);</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">&#125;)(<span class="built_in">window</span>.Sniffer || (<span class="built_in">window</span>.Sniffer = &#123;&#125;));</div></pre></td></tr></table></figure>
<h2 id="六、确定队列中单个项的内容"><a href="#六、确定队列中单个项的内容" class="headerlink" title="六、确定队列中单个项的内容"></a>六、确定队列中单个项的内容</h2><p> <strong>1. 指定检测的基点 base</strong><br> 由于运算符<code>in</code>工作时，需要几个基点给它检测。所以第一个要有的项就是<code>base</code></p>
<p> <strong>2. 检测的字符类型的方法名 name</strong><br> 像<code>Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);</code>，如果已经指定基点<code>{&#39;base&#39;:Wall}</code>，则还需要<code>message.setName</code>。所以要存储<code>message.setName</code>，也即<code>{&#39;base&#39;:Wall, &#39;name&#39;:&#39;message.setName&#39;}</code></p>
<p> <strong>3. 缓存方法的参数 args</strong><br> 像<code>Wall.message.setName(&#39;wang&#39;, &#39;wall&#39;);</code>，有两个参数<code>(&#39;wang&#39;, &#39;wall&#39;)</code>，所以需要存储起来。也即<code>{&#39;base&#39;:Wall, &#39;name&#39;:&#39;message.setName&#39;, &#39;args&#39;:[&#39;wang&#39;, &#39;wall&#39;]}</code>。</p>
<p> 为什么参数使用数组缓存起来，是因为方法的参数是变化的，所以后续的代码需要<code>apply</code>去做触发。同理，这里的参数就需要用数组进行缓存</p>
<p> 所以，缓存队列的单个项内容如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">'base'</span>:Wall,</div><div class="line">	<span class="string">'name'</span>:<span class="string">'message.setName'</span>,</div><div class="line">	<span class="string">'args'</span>:[<span class="string">'wang'</span>, <span class="string">'wall'</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="七、实现run方法"><a href="#七、实现run方法" class="headerlink" title="七、实现run方法"></a>七、实现run方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">FUN, undefined</span>)</span>&#123;</div><div class="line"><span class="meta">	'use strict'</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> list = []; <span class="comment">// 存储订阅的需要调用的方法</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* @function 函数转换接口，用于判断函数是否存在命名空间中，有则调用，无则不调用</div><div class="line">	* @version &#123;create&#125; 2015-11-30</div><div class="line">	* @description</div><div class="line">	*		用途：只设计用于延迟加载</div><div class="line">	*		示例：Wall.mytext.init(45, false);</div><div class="line">	*		调用：Sniffer.run(&#123;'base':window, 'name':'Wall.mytext.init'&#125;, 45, false);</div><div class="line">				或 Sniffer.run(&#123;'base':Wall, 'name':'mytext.init'&#125;, 45, false);</div><div class="line">	*		如果不知道参数的个数，不能直接写，可以用apply的方式调用当前方法</div><div class="line">	*		示例:  Sniffer.run.apply(window, [ &#123;'name':'Wall.mytext.init'&#125;, 45, false ]);</div><div class="line">	**/</div><div class="line">	FUN.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; <span class="number">1</span> || <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] != <span class="string">'object'</span>)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Sniffer.run 参数错误'</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">var</span> name = <span class="built_in">arguments</span>[<span class="number">0</span>].name, <span class="comment">// 函数名 0位为Object类型，方便做扩展</span></div><div class="line">			subscribe = <span class="built_in">arguments</span>[<span class="number">0</span>].subscribe || <span class="literal">false</span>, <span class="comment">// 订阅当函数可执行时，调用该函数, true:订阅; false:不订阅</span></div><div class="line">			prompt = <span class="built_in">arguments</span>[<span class="number">0</span>].prompt || <span class="literal">false</span>, <span class="comment">// 是否显示提示语(当函数未能执行的时候)</span></div><div class="line">			promptMsg = <span class="built_in">arguments</span>[<span class="number">0</span>].promptMsg || <span class="string">'功能还在加载中，请稍候'</span>, <span class="comment">// 函数未能执行提示语</span></div><div class="line">			base = <span class="built_in">arguments</span>[<span class="number">0</span>].base || <span class="built_in">window</span>, <span class="comment">// 基准对象，函数查找的起点</span></div><div class="line">			</div><div class="line">			args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>), <span class="comment">// 参数列表</span></div><div class="line">			funcArgs = args.slice(<span class="number">1</span>), <span class="comment">// 函数的参数列表</span></div><div class="line">			callbackFunc = &#123;&#125;, <span class="comment">// 临时存放需要回调的函数</span></div><div class="line">			result; <span class="comment">// 检测结果</span></div><div class="line"></div><div class="line">		result = checkMethod(name, base);</div><div class="line">		<span class="keyword">if</span>(result.success)&#123;</div><div class="line">			subscribe = <span class="literal">false</span>;</div><div class="line">			<span class="keyword">try</span>&#123;</div><div class="line">				<span class="keyword">return</span> result.func.apply(result.func, funcArgs); <span class="comment">// apply调整函数的指针指向</span></div><div class="line">			&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">				(<span class="keyword">typeof</span> <span class="built_in">console</span> != <span class="string">'undefined'</span>) &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'错误:name='</span>+ e.name +<span class="string">'; message='</span>+ e.message);</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">if</span>(prompt)&#123;</div><div class="line">				<span class="comment">// 输出提示语到页面，代码略</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//将订阅的函数缓存起来</span></div><div class="line">		<span class="keyword">if</span>(subscribe)&#123;</div><div class="line">			callbackFunc.name = name;</div><div class="line">			callbackFunc.base = base;</div><div class="line">			callbackFunc.args = funcArgs;</div><div class="line">			list.push(callbackFunc);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="comment">// 嗅探方法</span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">checkMethod</span>(<span class="params">funcName, base</span>)</span>&#123;</div><div class="line">		<span class="comment">// 代码...</span></div><div class="line">	&#125;</div><div class="line">&#125;)(<span class="built_in">window</span>.Sniffer || (<span class="built_in">window</span>.Sniffer = &#123;&#125;));</div></pre></td></tr></table></figure>
<p> run方法的作用是：检测方法是否可执行，可执行，则执行。不可执行，则根据传入的参数，决定要不要缓存。</p>
<p> 这个run方法的重点，是<strong>妙用<code>arguments</code>，实现0-n个参数自由传入</strong>。</p>
<blockquote>
<p> 第一个形参<code>arguments[0]</code>，固定是用来传入配置项的。存储要检测的基点<code>base</code>，方法字符串<code>argument[0].name</code>以及缓存标志<code>arguments[0].subscribe</code>。</p>
</blockquote>
<p> </p>
<blockquote>
<p> 第二个形参到第n个形参，则由方法调用者传入需要使用的参数。</p>
<p> 利用泛型方法，将<code>arguments</code>转换为真正的数组。（<code>args = Array.prototype.slice.call(arguments)</code>）<br> 然后，切割出方法调用需要用到的参数。（<code>funcArgs = args.slice(1)</code>）</p>
</blockquote>
<p> run方法的arguments处理完毕后，就可以调用<code>checkMethod</code>方法进行嗅探。</p>
<p> <strong>根据嗅探的结果，分两种情况</strong>：</p>
<blockquote>
<p> 嗅探结果为可执行，则调用apply执行<br> <code>return result.func.apply(result.func, funcArgs);</code></p>
</blockquote>
<p> 这里的重点是必须制定作用域为<code>result.func</code>，也即例子的<code>Wall.message.setName</code>。<br> 这样，如果方法中使用了<code>this</code>，指向也不会发生改变。</p>
<p> 使用<code>return</code>，是因为一些方法执行后是有返回值的，所以这里需要加上<code>return</code>，将返回值传递出去。</p>
<blockquote>
<p> 嗅探结果为不可执行，则根据传入的配置值<code>subscribe</code>，决定是否缓存到队列<code>list</code>中。<br> 需要缓存，则拼接好队列单个项，push进list。</p>
</blockquote>
<h2 id="八、实现trigger方法"><a href="#八、实现trigger方法" class="headerlink" title="八、实现trigger方法"></a>八、实现trigger方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">FUN, undefined</span>)</span>&#123;</div><div class="line"><span class="meta">	'use strict'</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> list = []; <span class="comment">// 存储订阅的需要调用的方法</span></div><div class="line"></div><div class="line">	<span class="comment">// 执行方法</span></div><div class="line">	FUN.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">// 代码...</span></div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	* @function 触发函数接口，调用已提前订阅的函数</div><div class="line">	* @param &#123;object&#125; option -- 需要调用的相关参数</div><div class="line">	* @description</div><div class="line">	*		用途：只设计用于延迟加载</div><div class="line">	*		另外，调用trigger方法的前提是，订阅方法所在js已经加载并解析完毕</div><div class="line">	*		不管触发成功与否，都会清除list中对应的项</div><div class="line">	**/</div><div class="line">	FUN.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> option !== <span class="string">'object'</span>)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Sniffer.trigger 参数错误'</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">var</span> funcName = option.name || <span class="string">''</span>, <span class="comment">// 函数名</span></div><div class="line">			base = option.base || <span class="built_in">window</span>, <span class="comment">// 基准对象，函数查找的起点</span></div><div class="line">			newList = [], <span class="comment">// 用于更新list</span></div><div class="line">			result, <span class="comment">// 检测结果</span></div><div class="line">			func, <span class="comment">// 存储执行方法的指针</span></div><div class="line">			i, <span class="comment">// 遍历list</span></div><div class="line">			param; <span class="comment">// 临时存储list[i]</span></div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(funcName.length &lt; <span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 遍历list，执行对应的函数，并将其从缓存池list中删除</span></div><div class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; list.length; i++)&#123;</div><div class="line">			param = list[i];</div><div class="line">			<span class="keyword">if</span>(param.name == funcName)&#123;</div><div class="line">				result = checkMethod(funcName, base);</div><div class="line">				<span class="keyword">if</span>( result.success )&#123;</div><div class="line">					<span class="keyword">try</span>&#123;</div><div class="line">						result.func.apply(result.func, param.args);</div><div class="line">					&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">						(<span class="keyword">typeof</span> <span class="built_in">console</span> != <span class="string">'undefined'</span>) &amp;&amp; <span class="built_in">console</span>.log &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'错误:name='</span>+ e.name +<span class="string">'; message='</span>+ e.message);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				newList.push(param);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		list = newList;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="comment">// 嗅探方法</span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">checkMethod</span>(<span class="params">funcName, base</span>)</span>&#123;</div><div class="line">		<span class="comment">// 代码...</span></div><div class="line">	&#125;</div><div class="line">&#125;)(<span class="built_in">window</span>.Sniffer || (<span class="built_in">window</span>.Sniffer = &#123;&#125;));</div></pre></td></tr></table></figure>
<p> 如果前面的<code>run</code>方法看懂了，<code>trigger</code>方法也就不难理解了。</p>
<blockquote>
<p> 1. 首先要告知<code>trigger</code>方法，需要从队列<code>list</code>中拿出哪个方法执行。<br> 2. 在执行方法之前，需要再次嗅探这个方法是否已经存在。存在了，才可以执行。否则，则可以认为方法已经不存在，可以从缓存中移除。</p>
</blockquote>
<hr>
<h2 id="九、实用性和可靠度"><a href="#九、实用性和可靠度" class="headerlink" title="九、实用性和可靠度"></a>九、实用性和可靠度</h2><p> 实用性这方面是毋容置疑的，不管是什么代码栈，Sniffer.js都值得你拥有！</p>
<p> 可靠度方面，Sniffer.js使用在高流量的公司产品上，至今没有出现反馈任何兼容、或者性能问题。这方面也可以打包票！</p>
<p> 最后，附上<a href="https://github.com/wall-wxk/sniffer/blob/master/sniffer.js" target="_blank" rel="external">源码地址</a>:<code>https://github.com/wall-wxk/sniffer/blob/master/sniffer.js</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、热身——先看实战代码&quot;&gt;&lt;a href=&quot;#一、热身——先看实战代码&quot; class=&quot;headerlink&quot; title=&quot;一、热身——先看实战代码&quot;&gt;&lt;/a&gt;一、热身——先看实战代码&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;a.js 文件&lt;/p&gt;
&lt;/blo
    
    </summary>
    
      <category term="JavaScript" scheme="https://wall-wxk.github.io/categories/JavaScript/"/>
    
      <category term="小作品" scheme="https://wall-wxk.github.io/categories/JavaScript/%E5%B0%8F%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="sniffer.js" scheme="https://wall-wxk.github.io/tags/sniffer-js/"/>
    
  </entry>
  
  <entry>
    <title>javascript模块化编程-详解立即执行函数表达式IIFE</title>
    <link href="https://wall-wxk.github.io/2017/02/13/moduleJs-IIFE/"/>
    <id>https://wall-wxk.github.io/2017/02/13/moduleJs-IIFE/</id>
    <published>2017-02-12T16:46:14.000Z</published>
    <updated>2017-02-18T15:00:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、IIFE解释"><a href="#一、IIFE解释" class="headerlink" title="一、IIFE解释"></a>一、IIFE解释</h2><blockquote>
<p>全拼Imdiately Invoked Function Expression，立即执行的函数表达式。</p>
</blockquote>
<p> 像如下的代码所示，就是一个匿名立即执行函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>)</span>&#123;</div><div class="line">  <span class="comment">// 代码...	</span></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<h2 id="二、括号的意义"><a href="#二、括号的意义" class="headerlink" title="二、括号的意义"></a>二、括号的意义</h2><p> <strong>2.1 包住<code>function(){}</code>的括号的意义</strong></p>
<p> 这个括号的目的，是为了把<code>function(){}</code>转化为表达式。像一些库的源码，喜欢用如下方式代替:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 代码...</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>或者这种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 代码...</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p> 其实，作用都一样，都是把<code>function(){}</code>转化成一个可执行的表达式，方便执行。<br> 如果去掉该括号，则会报错。因为单纯的<code>function(){}</code>不是可执行的表达式，会直接报错。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-5d8a86acafb1c800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> <strong>2.1 第二个括号的意义</strong></p>
<p> 理解了第一个括号的意义，第二个括号就很简单了，就是执行表达式了。</p>
<h2 id="三、参数的意义"><a href="#三、参数的意义" class="headerlink" title="三、参数的意义"></a>三、参数的意义</h2><p> 以这段代码为例子，讲解参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wall = &#123;&#125;;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	</div><div class="line">&#125;)(<span class="built_in">window</span>, wall);</div></pre></td></tr></table></figure>
<p> 参数分为形参和实参。<br> <code>function(window, WALL, undefined)</code>三个参数为形参，第二个括号<code>(window, wall)</code>的两个参数为实参。<br> 也即可以理解为 <code>window == window</code>，<code>wall == WALL</code>。</p>
<p> <strong>2.1 普通形参</strong></p>
<p> 普通形参是指由<code>window</code>和<code>wall</code>这样的实际变量传入指定，可以为任何类型的变量。一个形参就对应一个实参</p>
<p> <strong>2.2 特殊形参undefined</strong></p>
<p> 为什么形参要多写一个undefined，这是一个很有趣的话题。<br> 可以知道这个示例，实参只有两个，而形参有三个。所以在函数执行的时候，形参<code>undefined</code>会默认赋值为undefined。</p>
<p> 形参<code>undefined</code>的作用如下：</p>
<p> <strong>2.2.1 防止特殊值undefined被恶意代码篡改。</strong><br> IE6等低版本浏览器，undefined是支持被修改的。而这个特殊值被修改后，像以下这种判断就失效了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(wall == <span class="literal">undefined</span>)&#123;</div><div class="line">  <span class="comment">// 代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 所以，这里多加一个形参的目的就是为了防止这种情况发生。只要在这个IIFE作用域内，undefined就能够正常获取到。</p>
<p> <strong>2.2.2 压缩代码可以压缩undefined</strong><br> 因为undefined作为形参，像YUI compressor这种类型的代码压缩工具，可以将其相关的值进行压缩，减小文件的体积。</p>
<h2 id="四、写法解析"><a href="#四、写法解析" class="headerlink" title="四、写法解析"></a>四、写法解析</h2><p> <strong>4.1 普通写法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wall = &#123;&#125;; <span class="comment">// 声明定义一个命名空间wall</span></div><div class="line"></div><div class="line"><span class="comment">// 定义方法</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="comment">// 给wall命名空间绑定方法say</span></div><div class="line">	WALL.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">	&#125;;</div><div class="line">&#125;)(<span class="built_in">window</span>, wall);</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="comment">// 给wall命名空间绑定方法 whoIam</span></div><div class="line">	WALL.whoIam = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'wall'</span>);</div><div class="line">	&#125;;</div><div class="line">&#125;)(<span class="built_in">window</span>, wall);</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">wall.say();</div><div class="line">wall.whoIam();</div></pre></td></tr></table></figure>
<p> 先定义一个命名空间，然后再给这个命名空间加东西。这是最普遍的写法，也是最好理解的。<br> 不足的地方就是必须先声明一个命名空间，然后才能执行相关的绑定代码。存在顺序加载的问题。</p>
<p> <strong>4.2 放大模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wall = (<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> WALL == <span class="string">'undefined'</span>)&#123;</div><div class="line">		WALL = &#123;&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 给wall命名空间绑定方法say</span></div><div class="line">	WALL.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> WALL; <span class="comment">// 返回引用</span></div><div class="line">&#125;)(<span class="built_in">window</span>, wall);</div><div class="line"></div><div class="line"><span class="keyword">var</span> wall = (<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> WALL == <span class="string">'undefined'</span>)&#123;</div><div class="line">		WALL = &#123;&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 给wall命名空间绑定方法 whoIam</span></div><div class="line">	WALL.whoIam = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'wall'</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> WALL; <span class="comment">// 返回引用</span></div><div class="line">&#125;)(<span class="built_in">window</span>, wall);</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">wall.say();</div><div class="line">wall.whoIam();</div></pre></td></tr></table></figure>
<p> 放大模式的好处就是，可以不用考虑代码加载的先后顺序。<br> 因为js允许<code>wall</code>变量进行重复var声明，所以这段代码是可以执行的。<br> 我可以把IIFE函数拆分成多个文件进行加载，而不会出现普通写法需要注意的问题。</p>
<p> <strong>需要注意的点</strong>：<br> 1.IIFE的头部，都要先进行检查命名空间是否已经实例化，如果还没实例化，则进行实例化。<br> 2.IIFE的尾部，都要return命名空间的引用，使后续代码能够得到最新的<code>wall</code>命名空间内容。</p>
<p> <strong>4.3 宽放大模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="comment">// 给wall命名空间绑定方法say</span></div><div class="line">	WALL.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.wall || (<span class="built_in">window</span>.wall = &#123;&#125;));</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="comment">// 给wall命名空间绑定方法 whoIam</span></div><div class="line">	WALL.whoIam = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'wall'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.wall || (<span class="built_in">window</span>.wall = &#123;&#125;));</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">wall.say();</div><div class="line">wall.whoIam();</div></pre></td></tr></table></figure>
<p> <strong>宽放大模式的重点注意的地方：</strong>就是在实参部分的<code>window.wall || (window.wall = {})</code>。<br> 用||运算符进行取巧。<br> 如果<code>window.wall</code>是已经实例化的，非not defined。则直接返回<code>window.wall</code>的引用，赋值给形参<code>WALL</code>。不会执行||运算符后面的内容。<br> 如果<code>window.wall</code>还未实例化，则进行实例化。这里要注意的点是实例化是一个赋值操作，需要用括号包起来，变成表达式去执行，才不会报错。<br> 表达式<code>(window.wall = {})</code>执行完毕后，会返回新对象<code>window.wall</code>的引用。</p>
<p> <strong>宽放大模式的好处：</strong>是可以切割成多个文件进行加载，而不必考虑文件加载的先后顺序，不存在强耦合关系。<br> 当然，如果IIFE里面的方法互相引用，还是存在加载依赖的问题。这个问题可以用加载器Require.js等工具解决，这里就不讨论了。</p>
<h2 id="五、分文件加载IIFE要注意的点"><a href="#五、分文件加载IIFE要注意的点" class="headerlink" title="五、分文件加载IIFE要注意的点"></a>五、分文件加载IIFE要注意的点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="comment">// 给wall命名空间绑定方法say</span></div><div class="line">	WALL.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.wall || (<span class="built_in">window</span>.wall = &#123;&#125;));</div></pre></td></tr></table></figure>
<p> 眼尖的已经看出区别了，就是文件开始的地方，先写上分号<code>;</code>。<br> 这样，多个文件合并的时候，才不会出现收尾相接，代码出现错乱的问题。比如下面这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js 文件</span></div><div class="line">wall.log()</div><div class="line"></div><div class="line"><span class="comment">// b.js 文件</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, WALL, undefined</span>)</span>&#123;</div><div class="line">	<span class="comment">// 给wall命名空间绑定方法say</span></div><div class="line">	WALL.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.wall || (<span class="built_in">window</span>.wall = &#123;&#125;));</div></pre></td></tr></table></figure>
<p> 由于a.js文件的<code>wall.log()</code>少写了分号，跟b.js文件合并后，js就会认为‘wall.log()(…)’是需要这么执行的，结果代码就报错了。</p>
<hr>
<p> 觉得不错的，可以关注<code>模块化</code>这个系列的文章，容我后续码字，敬请期待！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、IIFE解释&quot;&gt;&lt;a href=&quot;#一、IIFE解释&quot; class=&quot;headerlink&quot; title=&quot;一、IIFE解释&quot;&gt;&lt;/a&gt;一、IIFE解释&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;全拼Imdiately Invoked Function Expr
    
    </summary>
    
      <category term="JavaScript" scheme="https://wall-wxk.github.io/categories/JavaScript/"/>
    
      <category term="模块化编程" scheme="https://wall-wxk.github.io/categories/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="IIFE" scheme="https://wall-wxk.github.io/tags/IIFE/"/>
    
  </entry>
  
  <entry>
    <title>localStorage的黑科技-js和css缓存机制</title>
    <link href="https://wall-wxk.github.io/2017/01/18/localStorage/"/>
    <id>https://wall-wxk.github.io/2017/01/18/localStorage/</id>
    <published>2017-01-18T12:30:36.000Z</published>
    <updated>2017-02-18T15:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、发现黑科技的起因"><a href="#一、发现黑科技的起因" class="headerlink" title="一、发现黑科技的起因"></a>一、发现黑科技的起因</h2><p> 今天在微信公众号看到一篇技术博文，想用印象笔记收藏，所以发送了文章链接到pc上。然后习惯性地打开控制台，看看源码，想了解下最近微信用了什么新技术。<br> 呵呵，以下勾起了我侦探的欲望。页面加载后的异常点就是只加载了一个js，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-b2ba6f7903ae5373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 我很诧异，为什么已经开启了Disable cache，js只加载了一个，而且体积这么小。接着，我按住Ctrl+O进行资源文件查找，发现我被“忽悠”了。其实根本就不止一个js文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-270d5d850ce777c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 脑袋里灵光一闪，不会是用localStorage做了缓存吧？！赶紧看了下localStronge,还真是。。。。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-6b1244b5dbf8fcac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 心里一阵澎湃，这不是我之前就想实现的加载性能优化的想法吗！乖乖，我孤陋寡闻了，已经有前端团队实现了代码。</p>
<h2 id="二、谈谈文件加载方面的优化思路"><a href="#二、谈谈文件加载方面的优化思路" class="headerlink" title="二、谈谈文件加载方面的优化思路"></a>二、谈谈文件加载方面的优化思路</h2><p> 通常，前端的资源文件加载优化，就是在文件不修改迭代的情况下，尽可能多地利用缓存，避免多次下载同样的文件。<br> 一般的做法就是尽量延长资源的有效期，也就是设置 Cache-Control里的max-age，使页面资源请求的返回码为304，让浏览器直接使用本地缓存。<br> 虽然pc端的协商缓存（304）很快，但手机端因为网络原因，协商缓存的效果就没pc端那么好了。而且，手机会经常清除本地缓存，所以文件缓存的时间也不会很长。<br> 这个时候，localStorage就派上用场了。<br> localStorage相比cookie，可以缓存大体积的数据，而且是永久有效。所以，如果把js资源和css资源存储在localStorage中，则可以省去发送http请求所消耗的时间，大大提高用户的浏览体验。</p>
<h2 id="三、用localStorage做资源缓存需要解决的问题"><a href="#三、用localStorage做资源缓存需要解决的问题" class="headerlink" title="三、用localStorage做资源缓存需要解决的问题"></a>三、用localStorage做资源缓存需要解决的问题</h2><p><strong>3.1 版本更新机制</strong> </p>
<p> 只要一个项目还在迭代开发，就难以避免需要更新资源文件。<br> 普通的资源请求，可以根据<br> 文件名+md5 <code>http://res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/moon32ebc4.js</code><br>  或者<br> 在资源链接后面加上特定的后缀<code>http://1.ss.faisys.com/js/comm/fai.min.js?v=201612051739</code><br> 做标识来判断是否需要更新资源。<br> 如果用localStorage做，则需要一套新的缓存更新机制。</p>
<p><strong>3.2 搭建更新代码的脚手架</strong></p>
<p> 使用localStorage缓存，则需要一个新的脚手架来管理资源文件的读取和写入。</p>
<p><strong>3.3 后台输出一份资源配置信息</strong></p>
<p> 因为需要前端做资源更新，所以后台要输出一份依据给前端做判断用，也就是需要一份资源配置信息。前端根据配置信息，进行匹配和比较，最终决定 使用localStorage缓存，还是重新发起请求，下载最新的资源文件。</p>
<p><strong>3.4 存在XSS安全隐患</strong></p>
<p> localStorage中的信息，客户端是可以任意修改的。如果哪个黑客想练手一下，可以任意注入js代码。那么，在页面刷新的时候，注入的代码也将会被执行。</p>
<h2 id="四、微信的做法解析"><a href="#四、微信的做法解析" class="headerlink" title="四、微信的做法解析"></a>四、微信的做法解析</h2><p><strong>4.1 版本标识</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-cbf76b763ada7c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 以<code>__MOON__a/a_report.js</code>为例，版本信息用key <code>__MOON__a/a_report.js_ver</code>存储，存储的value为<code>//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_report32e586.js</code>。<br> 如果按普通加载方式，直接将该value取出来，设置到script节点的src属性，即可完成加载。<br> 微信判断该版本是否最新，就是用该value值与后台输出的配置信息进行比较，最后得出是否更新的结果。<br> 如果value值与配置信息一致，则使用缓存。否则，重新发起请求加载。</p>
<p><strong>4.2 脚手架</strong></p>
<p> 可以看出，微信使用的是自己开发的脚手架moon.js，在这个网页中的实际文件名是<code>moon32ebc4.js</code>。<br> 因为是混淆过变量名的文件，所以要看出具体代码的走向，有点费劲，这里就不做分析了。</p>
<p><strong>4.3 资源配置信息</strong></p>
<p> 因为脚手架moon.js需要资源配置信息才能正常工作，所以配置信息一定会在moon.js之前输出。<br> 依次查看moon.js之前的script标签，发现了<code>window.moon_map</code>这个json对象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-330ad99b6ad63fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 利用控制台输出该变量查看信息如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-da2ca16b1807103d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 看到这里，可以明确一个点：这就是更新机制所必备的资源配置信息表了。<br> 而且，可以看出，该配置信息json对象的key，就对应localStorage中的key。同理，value值也是一一对应。</p>
<p><strong>4.4 XSS攻击</strong></p>
<p> 此处是为了验证微信的缓存机制是否存在XSS攻击，看到这里的童鞋可千万不要去做坏事。<br> 我在一个js缓存代码中，插入<code>alert(&quot;hehe&quot;);</code>，看页面刷新的时候，是否会出现该弹窗，来验证是否存在攻击漏洞。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-523039c65c00d3f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 刷新页面后，结果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-ad6a95f119b4ad16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> 可以看出，微信也没有解决这类问题。所以，这种缓存机制，还是有先天不足的。</p>
<p><strong>4.5 测试微信的更新机制</strong></p>
<p> 修改localStorage中 key <code>__MOON__a/a_report.js_ver</code>对应的value值，让微信的脚手架moon.js更新<code>__MOON__a/a_report.js</code>，刷掉我刚才主动插入的代码。<br> 这里，我修改文件名为<code>***587.js</code>（原来的文件名为<code>***586.js</code>）。接着F5刷新页面。<br> 结果为：report.js代码更新了，版本号也恢复回 <code>***586.js</code>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4118463-e2278e74c27b7cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p> localStorage缓存有其用武之地，但不是万能的。需要注意以上提及的坑。<br> 可以应用的场景我归纳为以下几点：</p>
<p>  <strong>1. 非首屏渲染需要的css文件，可以做LS缓存。</strong></p>
<p>  首屏渲染需要的css，需要按常规方式输出，因为SEO需要，不然爬虫爬取页面的时候，页面效果会很不好。而非首屏的css，则可以用LS缓存，减少资源下载时间。</p>
<p>  <strong>2. 展示类、动画类等非业务主要逻辑的代码，可以做LS缓存。</strong></p>
<p>  这样，可以一定程度上避免业务层的安全漏洞。当然，前端再怎么做防护都是一层薄纸。重要的，还是后台接口要做好安全保护。</p>
<p>  <strong>3. 移动端可以做LS缓存。PC端做LS缓存，起到的优化作用不大。</strong></p>
<h2 id="六、番外"><a href="#六、番外" class="headerlink" title="六、番外"></a>六、番外</h2><p> 有兴趣的童鞋，还可以看看知乎上大神们的讨论，<a href="https://www.zhihu.com/question/28467444" target="_blank" rel="external">静态资源（JS/CSS）存储在localStorage有什么缺点？为什么没有被广泛应用？ - 互联网 - 知乎</a><br> 另外，腾讯网的前端，在gitHub上有分享其<a href="https://mtjs.github.io/" target="_blank" rel="external">MT 模块管理框架</a>，可以看看具体的实现逻辑。<br> 最后，上一个栗子 —— 线上实例demo：<a href="http://scrat.io/" target="_blank" rel="external">webapp模块化开发体系</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、发现黑科技的起因&quot;&gt;&lt;a href=&quot;#一、发现黑科技的起因&quot; class=&quot;headerlink&quot; title=&quot;一、发现黑科技的起因&quot;&gt;&lt;/a&gt;一、发现黑科技的起因&lt;/h2&gt;&lt;p&gt; 今天在微信公众号看到一篇技术博文，想用印象笔记收藏，所以发送了文章链接到p
    
    </summary>
    
      <category term="JavaScript" scheme="https://wall-wxk.github.io/categories/JavaScript/"/>
    
    
      <category term="微信" scheme="https://wall-wxk.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="localStorage" scheme="https://wall-wxk.github.io/tags/localStorage/"/>
    
  </entry>
  
</feed>
